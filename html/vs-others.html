<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <title>EHTML vs Others</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="/image/favicon.ico"/>
    <link rel="preload" href="/html/main-page-template.html" as="fetch" crossorigin="anonymous" />
    <link rel="preload" href="/md/vs-others.md" as="fetch" crossorigin="anonymous" />
    <link rel="prefetch" href="/html/links.html?page=1" />
    <link rel="prefetch" href="/html/documentation.html?page=1" />
    <link rel="prefetch" href="/html/examples.html?page=1" />
    <link rel="prefetch" href="/html/applications.html?page=1" />
    <link rel="prefetch" href="/html/vs-others.html?page=1" />
    <link rel="stylesheet" href="/css/semanticss.css">
    <link rel="stylesheet" href="/css/highlights.css">
    <style>
      table {
        font-size: 0.85rem;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "#ehtml/": "/js/ehtml/",
          "#ehtml/main": "/js/ehtml/main.js?v=1a6f54c9"
        }
      }
    </script>
    <script type="module">import "#ehtml/main"</script>
    <script type="text/javascript" src="/js/utils.js"></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2Q7CQM1CWN">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-2Q7CQM1CWN');
    </script>
  </head>
  <body>
    <template
      is="e-wrapper"
      data-src="/html/main-page-template.html"
      data-where-to-place="main"
      data-how-to-place="inside">
      <h1>EHTML vs CSR vs SSR</h1>
      <s-scrollable>
        <table>
          <thead>
            <tr>
              <th id="area_/_feature">Area / Feature</th>
              <th id="**ehtml_(extended_html)**">
                <strong>EHTML (Extended HTML)</strong>
              </th>
              <th id="**csr_(client-side_rendering)**">
                <strong>CSR (Client-Side Rendering)</strong>
              </th>
              <th id="**ssr_(server-side_rendering)**">
                <strong>SSR (Server-Side Rendering)</strong>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <strong>Core Philosophy</strong>
              </td>
              <td>HTML-first. Enhanced with <code>&lt;template&gt;</code> and EHTML extensions. Browser remains the framework. </td>
              <td>JavaScript-first. UI is fully constructed from JS components.</td>
              <td>Server-first. HTML is generated on server using templating engines.</td>
            </tr>
            <tr>
              <td>
                <strong>Templating Model</strong>
              </td>
              <td>Native <code>&lt;template&gt;</code> + EHTML features like <code>mapToTemplate</code> and <code>releaseTemplate</code>. No templating engine needed. </td>
              <td>JSX, directives, component templates compiled into JS bundles.</td>
              <td>Requires templating engines (EJS, Rails ERB, Blade, Razor, etc.).</td>
            </tr>
            <tr>
              <td>
                <strong>Data Binding</strong>
              </td>
              <td>Declarative binding via <code>data-*</code> attributes. Data &amp; view always decoupled. Structured mapping built-in. </td>
              <td>Components tightly coupled with their data sources. Harder to trace.</td>
              <td>Data inserted during server render; templates don’t know where data came from.</td>
            </tr>
            <tr>
              <td>
                <strong>Nested Structures / Forms</strong>
              </td>
              <td>Built-in nested form support with automatic JSON serialization.</td>
              <td>Requires custom form logic or libraries.</td>
              <td>Server parses nested forms manually; limited dynamic interactions.</td>
            </tr>
            <tr>
              <td>
                <strong>Dynamic Updates</strong>
              </td>
              <td>Uses HTML <code>&lt;template&gt;</code> and dynamic mapping utilities. Can update just the part you need. </td>
              <td>Requires re-rendering component hierarchies, reconcilers, or signals.</td>
              <td>Typically needs full page reload unless enhanced by TurboLinks/Turbo Frames.</td>
            </tr>
            <tr>
              <td>
                <strong>Routing Model</strong>
              </td>
              <td>Simple: HTML files + JSON endpoints. No client router required.</td>
              <td>Client-side routing libraries required.</td>
              <td>Backend-driven routing; each route returns full HTML.</td>
            </tr>
            <tr>
              <td>
                <strong>Caching Strategy</strong>
              </td>
              <td>Strong. Data and templates are separated → headers/menus cached, content updated independently. Perfect for CDN/edge delivery.</td>
              <td>Weak. HTML is mostly empty, everything loads via JS, so CDN cannot cache rendered views.</td>
              <td>Limited. HTML and data tightly coupled → hard to cache partials; whole pages cached or nothing.</td>
            </tr>
            <tr>
              <td>
                <strong>Performance Profile</strong>
              </td>
              <td>Very light. No framework JS. Fastest first paint. Only dynamic data loaded when needed.</td>
              <td>Slow first load due to large JS bundles + hydration. High CPU overhead on client.</td>
              <td>Good first paint but waits for server to collect data. Entire page blocked until render finishes.</td>
            </tr>
            <tr>
              <td>
                <strong>Build Step</strong>
              </td>
              <td>None. Pure browser execution with optional ES modules/import maps.</td>
              <td>Always requires bundlers/transpilers (Webpack, Vite, SWC).</td>
              <td>No front-end build step, but requires server template compilation.</td>
            </tr>
            <tr>
              <td>
                <strong>Maintenance Complexity</strong>
              </td>
              <td>Extremely low. No framework churn. HTML remains stable for decades.</td>
              <td>High. Frequent framework updates, breaking changes, build-tool drift.</td>
              <td>Medium. Template engines are stable, but backend coupling increases maintenance.</td>
            </tr>
            <tr>
              <td>
                <strong>Data Flow Transparency</strong>
              </td>
              <td>Fully transparent: HTML declares data sources; logic minimal; easy debugging.</td>
              <td>Hard to trace. Logic split between components, hooks, effects, stores.</td>
              <td>Hard to trace: data lives in backend controllers/services, not visible in templates.</td>
            </tr>
            <tr>
              <td>
                <strong>Interactivity Level</strong>
              </td>
              <td>Excellent for most apps. Template mapping easily handles dynamic lists and partial updates.</td>
              <td>Very high, especially for complex, real-time or granular UI interactions.</td>
              <td>Limited without additional JS; mostly full reloads.</td>
            </tr>
            <tr>
              <td>
                <strong>WebSocket / Live Data</strong>
              </td>
              <td>Simple. EHTML patterns allow multi-template updates with minimal JS.</td>
              <td>Requires custom WebSocket clients + state management.</td>
              <td>Requires custom JS; server templates don’t help with real-time updates.</td>
            </tr>
            <tr>
              <td>
                <strong>SEO</strong>
              </td>
              <td>Excellent. Full HTML loads first, dynamic content fills in later.</td>
              <td>Poor by default. HTML is mostly JS bootstrapping → requires SSR for good SEO.</td>
              <td>Excellent. Search engines receive full HTML immediately.</td>
            </tr>
            <tr>
              <td>
                <strong>Progressive Enhancement</strong>
              </td>
              <td>Native. Without JS, most of the page still works.</td>
              <td>Weak. CSR often fails entirely without JS.</td>
              <td>Very strong. HTML-first.</td>
            </tr>
            <tr>
              <td>
                <strong>Component Reuse</strong>
              </td>
              <td>Use <code>&lt;template&gt;</code> as components—simple, portable, no toolchain required. </td>
              <td>Components require framework syntax + build chain.</td>
              <td>Limited. Templates reusable server-side but not client-side.</td>
            </tr>
            <tr>
              <td>
                <strong>Developer Experience</strong>
              </td>
              <td>Very high: simple HTML, declarative mapping, instant refresh, no virtual DOM.</td>
              <td>Heavy: component trees, dependency management, complex build pipelines.</td>
              <td>Moderate: templating straightforward, but tied deeply to backend stack.</td>
            </tr>
            <tr>
              <td>
                <strong>First Load Experience</strong>
              </td>
              <td>Fastest: minimal JS, static HTML served immediately.</td>
              <td>Slow: app waits for JS bundle download + execution.</td>
              <td>Can be slow: server waits for all data before sending HTML → blank screen until finished.</td>
            </tr>
            <tr>
              <td>
                <strong>Resilience / Failure Modes</strong>
              </td>
              <td>Very resilient: if dynamic data fails, static HTML still loads.</td>
              <td>Fragile: if JS fails, the whole page often breaks.</td>
              <td>Resilient: server returns HTML even if some data partials fail.</td>
            </tr>
            <tr>
              <td>
                <strong>Technology Lock-In</strong>
              </td>
              <td>Low. EHTML sugar is HTML-based and easy to migrate or remove.</td>
              <td>High. App structure locked into framework architecture.</td>
              <td>Medium. Migration depends on backend language and templating engine.</td>
            </tr>
            <tr>
              <td>
                <strong>Backend Dependency</strong>
              </td>
              <td>None. Backend just provides JSON + static HTML files.</td>
              <td>Tight. Must integrate frontend build pipeline with backend.</td>
              <td>Very tight. UI tied to backend language and templating engine.</td>
            </tr>
            <tr>
              <td>
                <strong>Debugging Simplicity</strong>
              </td>
              <td>Extremely easy: inspect HTML + data attributes; no hidden lifecycle magic.</td>
              <td>Hard: data flows through multiple layers (hooks, effects, stores, frameworks).</td>
              <td>Moderate: server logs + template debugging required.</td>
            </tr>
          </tbody>
        </table>  
      </s-scrollable>
    </template>
  </body>
</html>
